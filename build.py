#!/usr/bin/env python3

# This should be run manually whenever the video is changed, don't expect this to be often

# Taken and adapted from here:
# https://github.com/AlexandreSenpai/Bad-Apple/blob/main/run.py

from multiprocessing.pool import ThreadPool
from multiprocessing import cpu_count
from typing import Tuple
import time

import cv2
import tqdm


video_path = './assets/bad-apple.mp4'
code_gen_path = './src/video.c'
width, height = (64, 24)

# Set 1
start_frame = 40
end_frame = 1000
# Set 2
# start_frame = 326
# end_frame = 326*2
# Set 3
# start_frame = 326*2
# end_frame = 326*3
# Set 4
# start_frame = 326*3
# end_frame = 326*4
# Set 5
# start_frame = 326*4
# end_frame = 326*5
# Set 5
# start_frame = 326*5
# end_frame = 326*6


def write_frame(frame_information: Tuple[int, cv2.VideoCapture]):
    order, frame = frame_information
    
    y, x, _ = frame.shape
    pixel_row = 0
    
    frame_str = '    {\n'
    for j in range(height):
        frame_str += '        {'
        for i in reversed(range(width // 32)):
            # Assume width is always divisible by 32
            frame_str += '0b'
            for b in range(32):
                frame_str += '0' if frame[j, 31*i-b].all() == 0 else '1'
            frame_str += ', '

        frame_str += '},\n'
    frame_str += '    },\n'
    
    return order, frame_str
    

def generate_frames(video: cv2.VideoCapture):
    success = True
    order = 0
    i = 0
    
    while success and i < end_frame:
        i += 1
        success, frame = video.read()
        if i < start_frame:
            continue

        if i % 2 == 0:
            continue

        _, bw_frame = cv2.threshold(frame, 128, 255, cv2.THRESH_BINARY)


        if bw_frame is None:
            break
        
        y, x, _ = bw_frame.shape
        bw_frame = cv2.resize(bw_frame, (width, height))
        
        yield order, bw_frame
        
        order += 1

if __name__ == '__main__':
    
    video = cv2.VideoCapture(video_path)
    frame_cnt = int(video.get(cv2.CAP_PROP_FRAME_COUNT))
    
    with ThreadPool(processes=cpu_count()) as pool:
        frames = list(tqdm.tqdm(pool.imap(write_frame, generate_frames(video)), total=min(frame_cnt, (end_frame-start_frame)/2)))
        pool.close()
        pool.join()
        
    frames = sorted(frames, key=lambda x: x[0])
    
    with open(code_gen_path, 'w') as f:
        f.write('// This is an autogenerated array of pixel data made through build.py, do not edit this manually\n')
        # f.write('use tdriver::graphics;\n')
        # f.write(f'pub const FRAMES: [[[u32; graphics::WORDS]; graphics::HEIGHT]; {len(frames)}] = [\n')

        f.write(f'unsigned int frames[{len(frames)}][{height}][{int(width/32)}] = {{\n')
        for _, frame in frames:
            f.write(frame)

        f.write('};\n')
